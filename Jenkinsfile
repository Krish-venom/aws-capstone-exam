pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  parameters {
    choice(name: 'APP_VERSION', choices: ['app/v1', 'app/v2'], description: 'Which app version to deploy')
    booleanParam(name: 'DESTROY_AFTER', defaultValue: false, description: 'Destroy infra after deployment (for cleanup)')
  }

  environment {
    AWS_DEFAULT_REGION        = 'us-east-1'
    ANSIBLE_HOST_KEY_CHECKING = 'False'
    TF_IN_AUTOMATION          = 'true'
  }

  triggers {
    // Enable GitHub webhook if desired:
    // githubPush()
  }

  stages {
    stage('Checkout') {
      steps {
        git branch: 'main', url: 'https://github.com/Krish-venom/aws-capstone-exam.git'
      }
    }

    stage('Terraform Init/Plan/Apply (Generates Ansible Files)') {
      steps {
        dir('terraform') {
          // If your Jenkins agent does NOT have an IAM role, uncomment withCredentials and create Jenkins AWS creds with ID 'aws_creds'
          // withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_creds']]) {
          sh '''
            terraform --version
            if [ ! -f terraform.tfvars ]; then
              echo "[ERROR] terraform.tfvars missing. Provide region, my_ip_cidr, app_repo_url."
              exit 1
            fi

            echo "==> Terraform init/plan/apply (app_src_version=${APP_VERSION})"
            terraform init -input=false
            terraform plan -input=false -out=tfplan -var app_src_version="${APP_VERSION}"
            terraform apply -input=false -auto-approve tfplan

            # Optional: export outputs for reference (Ansible files are already generated by TF)
            terraform output -json > ../ansible/terraform-outputs.json || true
          '''
          // }
        }
      }
    }

    stage('Review Generated Ansible Artifacts') {
      steps {
        sh '''
          echo "Listing generated Ansible files..."
          ls -R ansible || true
          echo "Sanitized group_vars/all.yml (mask db_pass if present):"
          if [ -f ansible/group_vars/all.yml ]; then
            sed -E 's/(db_pass: ).*/\\1****/' ansible/group_vars/all.yml | sed -n '1,200p'
          else
            echo "[WARN] ansible/group_vars/all.yml not found"
          fi
        '''
      }
    }

    stage('Deploy with Ansible (Run from Jenkins)') {
      steps {
        dir('ansible') {
          sh '''
            KEY="../terraform/generated_streamline_key.pem"
            if [ ! -f "$KEY" ]; then
              echo "[ERROR] Terraform-generated key not found at $KEY"
              ls -l ../terraform
              exit 1
            fi
            chmod 600 "$KEY"

            if [ ! -f hosts.ini ]; then
              echo "[ERROR] hosts.ini not found (Terraform should have generated it)."
              exit 1
            fi
            echo "Inventory:"
            cat hosts.ini

            # Optionally override version at deploy-time (kept off to demonstrate TF as source-of-truth)
            # sed -i 's|^app_src_version:.*|app_src_version: "'${APP_VERSION}'"|' group_vars/all.yml

            echo "==> Ansible ping"
            ansible -i hosts.ini all -m ping -u ubuntu --key-file "$KEY"

            echo "==> Ansible deploy"
            ansible-playbook -i hosts.ini site.yml -u ubuntu --key-file "$KEY"
          '''
        }
      }
    }

    stage('Smoke Tests (ALB)') {
      steps {
        dir('ansible') {
          sh '''
            if [ ! -f group_vars/all.yml ]; then
              echo "[ERROR] group_vars/all.yml not found"
              exit 1
            fi

            ALB=$(grep '^alb_dns_name:' group_vars/all.yml | awk '{print $2}')
            if [ -z "$ALB" ]; then
              echo "[ERROR] alb_dns_name not found in group_vars/all.yml"
              exit 1
            fi
            echo "Testing ALB: http://$ALB"

            echo "GET /"
            curl -fsS --max-time 25 "http://$ALB/" | head -n 30

            echo "GET /db_check.php"
            curl -fsS --max-time 25 "http://$ALB/db_check.php" | tee /tmp/db_check.txt

            echo "Expecting DB success..."
            grep -q "Database Connected Successfully" /tmp/db_check.txt
          '''
        }
      }
    }

    stage('Optional Destroy') {
      when { expression { return params.DESTROY_AFTER } }
      steps {
        dir('terraform') {
          sh '''
            echo "==> Destroying infra as requested (DESTROY_AFTER=true)"
            terraform destroy -auto-approve -input=false
          '''
        }
      }
    }
  }

  post {
    success {
      echo '✅ Pipeline completed successfully.'
    }
    failure {
      echo '❌ Pipeline failed. Check stage logs.'
    }
    always {
      archiveArtifacts artifacts: 'ansible/**, terraform/generated_*_key.pem', allowEmptyArchive: true
    }
  }
}
