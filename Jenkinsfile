pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  parameters {
    choice(name: 'APP_VERSION', choices: ['app/v1', 'app/v2'], description: 'Which app version to deploy')
    booleanParam(name: 'DESTROY_AFTER', defaultValue: false, description: 'Destroy infra after deployment (for cleanup)')
  }

  environment {
    AWS_DEFAULT_REGION        = 'us-east-1'
    ANSIBLE_HOST_KEY_CHECKING = 'False'
    TF_IN_AUTOMATION          = 'true'
  }

  triggers {
    // If you configured a GitHub webhook, this will auto-build on push:
    githubPush()
  }

  stages {
    stage('Checkout') {
      steps {
        // Your repo with app/, terraform/, (and Ansible auto-generated by Terraform)
        git branch: 'main', url: 'https://github.com/Krish-venom/aws-capstone-exam.git'
      }
    }

    stage('Terraform Init & Apply (Infra)') {
      steps {
        dir('terraform') {
          // If your Jenkins agent does NOT have an IAM role, uncomment this block and create AWS creds with ID 'aws_creds':
          // withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_creds']]) {
          sh '''
            set -e
            terraform --version
            if [ ! -f terraform.tfvars ]; then
              echo "[ERROR] terraform.tfvars not found. It must contain: region, my_ip_cidr, app_repo_url."
              exit 1
            fi

            echo "[INFO] Initializing Terraform..."
            terraform init -input=false

            echo "[INFO] Planning with app version: ${APP_VERSION}"
            terraform plan -input=false -out=tfplan -var app_src_version="${APP_VERSION}"

            echo "[INFO] Applying..."
            terraform apply -input=false -auto-approve tfplan

            # (Optional) Capture outputs for reference; Ansible files are already generated by Terraform.
            terraform output -json > ../ansible/terraform-outputs.json || true
          '''
          // }
        }
      }
    }

    stage('Verify Ansible Artifacts (Generated by Terraform)') {
      steps {
        sh '''
          set -e
          echo "[INFO] Checking Terraform-generated Ansible files..."
          test -f ansible/hosts.ini || { echo "[ERROR] ansible/hosts.ini missing (Terraform autogen failed)"; exit 1; }
          test -f ansible/group_vars/all.yml || { echo "[ERROR] ansible/group_vars/all.yml missing"; exit 1; }
          test -f ansible/site.yml || { echo "[ERROR] ansible/site.yml missing"; exit 1; }
          test -f terraform/generated_streamline_key.pem || { echo "[ERROR] PEM not found at terraform/generated_streamline_key.pem"; exit 1; }

          echo "[INFO] Inventory:"
          cat ansible/hosts.ini

          echo "[INFO] Vars (masking db_pass):"
          sed -E 's/(db_pass: ).*/\\1****/' ansible/group_vars/all.yml || true
        '''
      }
    }

    stage('Deploy with Ansible (Run from Jenkins)') {
      steps {
        dir('ansible') {
          sh '''
            set -e
            KEY="../terraform/generated_streamline_key.pem"
            chmod 600 "$KEY"

            echo "[INFO] Ansible ping..."
            ansible -i hosts.ini all -m ping -u ubuntu --key-file "$KEY"

            echo "[INFO] Ansible deploy (site.yml)..."
            ansible-playbook -i hosts.ini site.yml -u ubuntu --key-file "$KEY"
          '''
        }
      }
    }

    stage('Smoke Tests (ALB)') {
      steps {
        dir('ansible') {
          sh '''
            set -e
            ALB=$(grep '^alb_dns_name:' group_vars/all.yml | awk '{print $2}')
            if [ -z "$ALB" ]; then
              echo "[ERROR] alb_dns_name not found in group_vars/all.yml"
              exit 1
            fi
            echo "[INFO] Testing ALB: http://$ALB"

            echo "GET /"
            curl -fsS --max-time 25 "http://$ALB/" | head -n 20

            echo "GET /db_check.php"
            curl -fsS --max-time 25 "http://$ALB/db_check.php" | tee /tmp/db_check.txt

            echo "[INFO] Expecting database connectivity success..."
            grep -q "Database Connected Successfully" /tmp/db_check.txt
          '''
        }
      }
    }
  }

  post {
    success {
      echo "✅ Pipeline successful."
      script {
        if (params.DESTROY_AFTER) {
          echo "DESTROY_AFTER=true → destroying infra now."
          dir('terraform') {
            sh 'terraform destroy -auto-approve -input=false'
          }
        } else {
          echo "Resources left running. Remember to run terraform destroy later to avoid charges."
        }
      }
    }
    failure {
      echo "❌ Pipeline failed. Check the stage logs above."
    }
    always {
      archiveArtifacts artifacts: 'ansible/**, terraform/generated_*_key.pem', allowEmptyArchive: true
    }
  }
}
